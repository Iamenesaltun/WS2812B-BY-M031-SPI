; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=527 -DxxDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;504      */
;;;505    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L1.28|
;;;506    {
;;;507        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L1.32|
000008  6148              STR      r0,[r1,#0x14]
;;;508        SysTick->VAL  = (0x0UL);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;509        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L1.18|
;;;510    
;;;511        /* Waiting for down-count to zero */
;;;512        while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0UL){
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L1.18|
;;;513    		
;;;514    		}
;;;515    
;;;516        /* Disable SysTick counter */
;;;517        SysTick->CTRL = 0UL;
000018  610a              STR      r2,[r1,#0x10]
;;;518    }
00001a  4770              BX       lr
;;;519    
                          ENDP

                  |L1.28|
                          DCD      CyclesPerUs
                  |L1.32|
                          DCD      0xe000e000

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;143    
;;;144    void SPI_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;145    {
;;;146        /*---------------------------------------------------------------------------------------------------------*/
;;;147        /* Init SPI                                                                                                */
;;;148        /*---------------------------------------------------------------------------------------------------------*/
;;;149        /* Configure as a master, clock idle low, 24-bit transaction, drive output on falling clock edge and latch input on rising edge. */
;;;150        /* Set IP clock divider. SPI clock rate = 2.5MHz */
;;;151        SPI_Open(SPI0, SPI_MASTER, SPI_MODE_0,24, SPI_CLK_FREQ);
000002  4807              LDR      r0,|L2.32|
000004  4c07              LDR      r4,|L2.36|
000006  9000              STR      r0,[sp,#0]
000008  2318              MOVS     r3,#0x18
00000a  2204              MOVS     r2,#4
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI_Open
;;;152    
;;;153        /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;154        SPI_EnableAutoSS(SPI0, SPI_SS, SPI_SS_ACTIVE_LOW);
000014  2200              MOVS     r2,#0
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPI_EnableAutoSS
;;;155    }
00001e  bd38              POP      {r3-r5,pc}
;;;156    
                          ENDP

                  |L2.32|
                          DCD      0x002625a0
                  |L2.36|
                          DCD      0x40061000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;96     
;;;97     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99         /*---------------------------------------------------------------------------------------------------------*/
;;;100        /* Init System Clock                                                                                       */
;;;101        /*---------------------------------------------------------------------------------------------------------*/
;;;102        /* Enable HIRC clock */
;;;103        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       CLK_EnableXtalRC
;;;104    		CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLKSEL_HIRC_DIV2);
000008  2038              MOVS     r0,#0x38
00000a  f7fffffe          BL       CLK_SetSysTickClockSrc
;;;105        /* Waiting for HIRC clock ready */
;;;106        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000e  2010              MOVS     r0,#0x10
000010  f7fffffe          BL       CLK_WaitClockReady
;;;107    
;;;108        /* Switch HCLK clock source to HIRC and HCLK source divide 1 */
;;;109        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000014  2100              MOVS     r1,#0
000016  2007              MOVS     r0,#7
000018  f7fffffe          BL       CLK_SetHCLK
;;;110    
;;;111        /* Select HIRC as the clock source of UART0 */
;;;112        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
00001c  2103              MOVS     r1,#3
00001e  2200              MOVS     r2,#0
000020  0609              LSLS     r1,r1,#24
000022  480f              LDR      r0,|L3.96|
000024  f7fffffe          BL       CLK_SetModuleClock
;;;113    
;;;114        /* Select PCLK1 as the clock source of SPI0 */
;;;115        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000028  4c0e              LDR      r4,|L3.100|
00002a  2200              MOVS     r2,#0
00002c  2120              MOVS     r1,#0x20
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       CLK_SetModuleClock
;;;116    
;;;117        /* Enable SPI0 peripheral clock */
;;;118        CLK_EnableModuleClock(SPI0_MODULE);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       CLK_EnableModuleClock
;;;119    
;;;120        /*---------------------------------------------------------------------------------------------------------*/
;;;121        /* Init I/O Multi-function                                                                                 */
;;;122        /*---------------------------------------------------------------------------------------------------------*/
;;;123        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;124        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |
00003a  07a0              LSLS     r0,r4,#30
00003c  6bc1              LDR      r1,[r0,#0x3c]
00003e  22ff              MOVS     r2,#0xff
000040  0412              LSLS     r2,r2,#16
000042  4391              BICS     r1,r1,r2
000044  2233              MOVS     r2,#0x33
000046  0452              LSLS     r2,r2,#17
000048  1889              ADDS     r1,r1,r2
00004a  63c1              STR      r1,[r0,#0x3c]
;;;125                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;126    
;;;127        /* Setup SPI0 multi-function pins */
;;;128        /* PA.3 is SPI0_SS,   PA.2 is SPI0_CLK,
;;;129           PA.1 is SPI0_MISO, PA.0 is SPI0_MOSI*/
;;;130        SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA3MFP_Msk |
00004c  6b01              LDR      r1,[r0,#0x30]
00004e  4a06              LDR      r2,|L3.104|
000050  0c09              LSRS     r1,r1,#16
000052  0409              LSLS     r1,r1,#16
000054  1889              ADDS     r1,r1,r2
000056  6301              STR      r1,[r0,#0x30]
;;;131                                           SYS_GPA_MFPL_PA2MFP_Msk |
;;;132                                           SYS_GPA_MFPL_PA1MFP_Msk |
;;;133                                           SYS_GPA_MFPL_PA0MFP_Msk)) |
;;;134                        (SYS_GPA_MFPL_PA3MFP_SPI0_SS |
;;;135                         SYS_GPA_MFPL_PA2MFP_SPI0_CLK |
;;;136                         SYS_GPA_MFPL_PA1MFP_SPI0_MISO |
;;;137                         SYS_GPA_MFPL_PA0MFP_SPI0_MOSI);
;;;138    
;;;139        /* Update System Core Clock */
;;;140        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and CyclesPerUs automatically. */
;;;141        SystemCoreClockUpdate();
000058  f7fffffe          BL       SystemCoreClockUpdate
;;;142    }
00005c  bd10              POP      {r4,pc}
;;;143    
                          ENDP

00005e  0000              DCW      0x0000
                  |L3.96|
                          DCD      0x5f803d10
                  |L3.100|
                          DCD      0x6640000d
                  |L3.104|
                          DCD      0x00004444

                          AREA ||i.data_bit8_to_bit24||, CODE, READONLY, ALIGN=1

                  data_bit8_to_bit24 PROC
;;;49     
;;;50     unsigned int data_bit8_to_bit24(uint8_t data){
000000  b5f0              PUSH     {r4-r7,lr}
000002  4604              MOV      r4,r0
;;;51     uint32_t conv_data=0;
000004  2000              MOVS     r0,#0
;;;52     int8_t x=0;
;;;53     uint32_t bit0=4;  //100 
000006  2304              MOVS     r3,#4
;;;54     uint32_t bit1=6;  //110
000008  2206              MOVS     r2,#6
;;;55     
;;;56     for(x=7;x>=0;x--){
00000a  2107              MOVS     r1,#7
;;;57     if (data&(1<<x))
00000c  2501              MOVS     r5,#1
                  |L4.14|
00000e  462e              MOV      r6,r5
000010  408e              LSLS     r6,r6,r1
000012  4226              TST      r6,r4
000014  d003              BEQ      |L4.30|
;;;58     conv_data=conv_data|(bit1<<(3*x));
000016  004e              LSLS     r6,r1,#1
000018  198f              ADDS     r7,r1,r6
00001a  4616              MOV      r6,r2
00001c  e002              B        |L4.36|
                  |L4.30|
;;;59     else
;;;60     conv_data=conv_data|(bit0<<(3*x));
00001e  004e              LSLS     r6,r1,#1
000020  198f              ADDS     r7,r1,r6
000022  461e              MOV      r6,r3
                  |L4.36|
000024  40be              LSLS     r6,r6,r7
000026  1e49              SUBS     r1,r1,#1
000028  4330              ORRS     r0,r0,r6
00002a  b249              SXTB     r1,r1                 ;56
00002c  2900              CMP      r1,#0                 ;56
00002e  daee              BGE      |L4.14|
;;;61     }
;;;62     return conv_data;
;;;63     }
000030  bdf0              POP      {r4-r7,pc}
;;;64     
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;65     int8_t counter=0;
;;;66     int main(void)
000000  2059              MOVS     r0,#0x59
000002  4c1c              LDR      r4,|L5.116|
000004  2116              MOVS     r1,#0x16
000006  2288              MOVS     r2,#0x88
                  |L5.8|
000008  6020              STR      r0,[r4,#0]
00000a  6021              STR      r1,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6823              LDR      r3,[r4,#0]
000010  2b00              CMP      r3,#0
000012  d0f9              BEQ      |L5.8|
;;;67     {
;;;68     /* Unlock protected registers */
;;;69     SYS_UnlockReg();
;;;70     /* Init System, IP clock and multi-function I/O. */
;;;71     SYS_Init();
000014  f7fffffe          BL       SYS_Init
000018  2000              MOVS     r0,#0
00001a  6020              STR      r0,[r4,#0]
;;;72     /* Lock protected registers */
;;;73     SYS_LockReg();
;;;74     /* Init SPI */
;;;75     SPI_Init();
00001c  f7fffffe          BL       SPI_Init
;;;76     send_array_clear();
000020  f7fffffe          BL       send_array_clear
;;;77     
;;;78     while(1){
;;;79     
;;;80     for(counter=LED_NUMBER-1;counter>=0;counter--){
000024  2709              MOVS     r7,#9
000026  4c14              LDR      r4,|L5.120|
;;;81     send_led_commands(counter,255-counter*28,counter*28,0);
000028  25ff              MOVS     r5,#0xff
                  |L5.42|
;;;82     CLK_SysTickDelay(100000); //wait 100 miliseconds
00002a  4e14              LDR      r6,|L5.124|
00002c  7027              STRB     r7,[r4,#0]            ;80
                  |L5.46|
00002e  7820              LDRB     r0,[r4,#0]            ;81  ; counter
000030  211c              MOVS     r1,#0x1c              ;81
000032  4603              MOV      r3,r0                 ;81
000034  434b              MULS     r3,r1,r3              ;81
000036  1ae9              SUBS     r1,r5,r3              ;81
000038  b2da              UXTB     r2,r3                 ;81
00003a  b2c9              UXTB     r1,r1                 ;81
00003c  2300              MOVS     r3,#0                 ;81
00003e  f7fffffe          BL       send_led_commands
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       CLK_SysTickDelay
000048  7820              LDRB     r0,[r4,#0]            ;80  ; counter
00004a  1e40              SUBS     r0,r0,#1              ;80
00004c  b240              SXTB     r0,r0                 ;80
00004e  7020              STRB     r0,[r4,#0]            ;80
000050  2800              CMP      r0,#0                 ;80
000052  daec              BGE      |L5.46|
;;;83     }
;;;84     
;;;85     CLK_SysTickDelay(1000000); //wait 3 seconds
000054  4e0a              LDR      r6,|L5.128|
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       CLK_SysTickDelay
;;;86     CLK_SysTickDelay(1000000);
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       CLK_SysTickDelay
;;;87     CLK_SysTickDelay(1000000);
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       CLK_SysTickDelay
;;;88     
;;;89     send_array_clear(); //Turn off all LEDs on strip
000068  f7fffffe          BL       send_array_clear
;;;90     
;;;91     CLK_SysTickDelay(1000000); //wait 1 second
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       CLK_SysTickDelay
000072  e7da              B        |L5.42|
;;;92     
;;;93     }
;;;94     }
;;;95     
                          ENDP

                  |L5.116|
                          DCD      0x40000100
                  |L5.120|
                          DCD      ||.data||
                  |L5.124|
                          DCD      0x000186a0
                  |L5.128|
                          DCD      0x000f4240

                          AREA ||i.send_array_clear||, CODE, READONLY, ALIGN=2

                  send_array_clear PROC
;;;13     
;;;14     void send_array_clear(void){
000000  b510              PUSH     {r4,lr}
;;;15     uint8_t led_counter=0;
;;;16     
;;;17     for(led_counter=0;led_counter<=LED_NUMBER;led_counter++){
;;;18     SPI_WRITE_TX(SPI0,0x924924);
000002  4b08              LDR      r3,|L6.36|
000004  4908              LDR      r1,|L6.40|
000006  2000              MOVS     r0,#0                 ;15
                  |L6.8|
000008  620b              STR      r3,[r1,#0x20]
;;;19     SPI_WRITE_TX(SPI0, 0x924924);
00000a  620b              STR      r3,[r1,#0x20]
;;;20     SPI_WRITE_TX(SPI0, 0x924924);
00000c  620b              STR      r3,[r1,#0x20]
                  |L6.14|
;;;21     while(SPI_IS_BUSY(SPI0));	
00000e  694a              LDR      r2,[r1,#0x14]
000010  07d2              LSLS     r2,r2,#31
000012  d1fc              BNE      |L6.14|
000014  1c40              ADDS     r0,r0,#1
000016  b2c0              UXTB     r0,r0                 ;17
000018  280a              CMP      r0,#0xa               ;17
00001a  d9f5              BLS      |L6.8|
;;;22     }
;;;23     CLK_SysTickDelay(200);	
00001c  20c8              MOVS     r0,#0xc8
00001e  f7fffffe          BL       CLK_SysTickDelay
;;;24     }
000022  bd10              POP      {r4,pc}
;;;25     
                          ENDP

                  |L6.36|
                          DCD      0x00924924
                  |L6.40|
                          DCD      0x40061000

                          AREA ||i.send_led_commands||, CODE, READONLY, ALIGN=2

                  send_led_commands PROC
;;;26     
;;;27     void send_led_commands(uint8_t Led_number, uint8_t G,uint8_t R,uint8_t B){
000000  b5ff              PUSH     {r0-r7,lr}
000002  4605              MOV      r5,r0
000004  b081              SUB      sp,sp,#4
000006  4617              MOV      r7,r2
;;;28     uint8_t led_counter=0;
000008  2400              MOVS     r4,#0
;;;29     uint32_t dataG,dataR,dataB=0;
;;;30     
;;;31     dataG=data_bit8_to_bit24(G);  //Transform 8bit green data to 24bit data
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       data_bit8_to_bit24
000010  4606              MOV      r6,r0
;;;32     dataR=data_bit8_to_bit24(R);  //Transform 8bit red data to 24bit data
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       data_bit8_to_bit24
000018  4607              MOV      r7,r0
;;;33     dataB=data_bit8_to_bit24(B);  //Transform 8bit blue data to 24bit data
00001a  9804              LDR      r0,[sp,#0x10]
00001c  f7fffffe          BL       data_bit8_to_bit24
000020  4602              MOV      r2,r0
;;;34     
;;;35     for(led_counter=0;led_counter<Led_number;led_counter++){
;;;36     SPI_WRITE_TX(SPI0,0x924924);   //Send 0 bit turn off green color
000022  490c              LDR      r1,|L7.84|
000024  4b0c              LDR      r3,|L7.88|
000026  e007              B        |L7.56|
                  |L7.40|
000028  620b              STR      r3,[r1,#0x20]
;;;37     SPI_WRITE_TX(SPI0, 0x924924);  //Send 0 bit turn off red color 
00002a  620b              STR      r3,[r1,#0x20]
;;;38     SPI_WRITE_TX(SPI0, 0x924924);  //Send 0 bit turn off blue color
00002c  620b              STR      r3,[r1,#0x20]
                  |L7.46|
;;;39     while(SPI_IS_BUSY(SPI0));	     // wait for communication
00002e  6948              LDR      r0,[r1,#0x14]
000030  07c0              LSLS     r0,r0,#31
000032  d1fc              BNE      |L7.46|
000034  1c64              ADDS     r4,r4,#1
000036  b2e4              UXTB     r4,r4                 ;35
                  |L7.56|
000038  42ac              CMP      r4,r5                 ;35
00003a  d3f5              BCC      |L7.40|
;;;40     }
;;;41     
;;;42     SPI_WRITE_TX(SPI0, dataG); // Send green color code
00003c  620e              STR      r6,[r1,#0x20]
;;;43     SPI_WRITE_TX(SPI0, dataR); // Send red color code
00003e  620f              STR      r7,[r1,#0x20]
;;;44     SPI_WRITE_TX(SPI0, dataB); // Send blue color code
000040  620a              STR      r2,[r1,#0x20]
                  |L7.66|
;;;45     while(SPI_IS_BUSY(SPI0));	 // wait for communication
000042  6948              LDR      r0,[r1,#0x14]
000044  07c0              LSLS     r0,r0,#31
000046  d1fc              BNE      |L7.66|
;;;46     
;;;47     CLK_SysTickDelay(200);  //wait for 200us for reset code
000048  20c8              MOVS     r0,#0xc8
00004a  f7fffffe          BL       CLK_SysTickDelay
;;;48     }
00004e  b005              ADD      sp,sp,#0x14
000050  bdf0              POP      {r4-r7,pc}
;;;49     
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      0x40061000
                  |L7.88|
                          DCD      0x00924924

                          AREA ||.data||, DATA, ALIGN=0

                  counter
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_aa066620____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_aa066620____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_aa066620____REVSH|
#line 402
|__asm___6_main_c_aa066620____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
